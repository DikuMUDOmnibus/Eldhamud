/****************************************************************************
 *			Eldhamud Codebase V2.2				    *
 * ------------------------------------------------------------------------ *
 *          EldhaMUD code (C) 2003-2008 by Robert Powell (Tommi)            *
 * ------------------------------------------------------------------------ *
 *                         mental skills file                               *
 ****************************************************************************/

#include "./Headers/mud.h"

ch_ret spell_cure_blindness ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	SKILLTYPE *skill = get_skilltype ( sn );
	set_char_color ( AT_MAGIC, ch );
	if ( IS_SET ( victim->immune, RIS_MAGIC ) )
	{
		immune_casting ( skill, ch, victim, NULL );
		return rSPELL_FAILED;
	}
	if ( !is_affected ( victim, gsn_blindness ) )
	{
		if ( ch != victim )
			send_to_char ( "You work your cure, but it has no apparent effect.\r\n", ch );
		else
			send_to_char ( "You don't seem to be blind.\r\n", ch );
		return rSPELL_FAILED;
	}
	affect_strip ( victim, gsn_blindness );
	set_char_color ( AT_MAGIC, victim );
	send_to_char ( "Your vision returns!\r\n", victim );
	if ( ch != victim )
		send_to_char ( "You work your cure, restoring vision.\r\n", ch );
	return rNONE;
}

ch_ret spell_cure_poison ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	SKILLTYPE *skill = get_skilltype ( sn );
	if ( IS_SET ( victim->immune, RIS_MAGIC ) )
	{
		immune_casting ( skill, ch, victim, NULL );
		return rSPELL_FAILED;
	}
	if ( is_affected ( victim, gsn_poison ) )
	{
		affect_strip ( victim, gsn_poison );
		set_char_color ( AT_MAGIC, victim );
		send_to_char ( "A warm feeling runs through your body.\r\n", victim );
		if ( ch != victim )
		{
			act ( AT_MAGIC, "A flush of health washes over $N.", ch, NULL, victim, TO_NOTVICT );
			act ( AT_MAGIC, "You lift the poison from $N's body.", ch, NULL, victim, TO_CHAR );
		}
		return rNONE;
	}
	else
	{
		set_char_color ( AT_MAGIC, ch );
		if ( ch != victim )
			send_to_char ( "You work your cure, but it has no apparent effect.\r\n", ch );
		else
			send_to_char ( "You don't seem to be poisoned.\r\n", ch );
		return rSPELL_FAILED;
	}
}

ch_ret spell_dispel_magic ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA *paf, *paf_next;
	SKILLTYPE *skill = NULL;
	set_char_color ( AT_MAGIC, ch );
	if ( victim != ch )
	{
		/* Edited by Tarl 27 Mar 02 to correct */
		if ( saves_mental ( victim ) )
		{
			set_char_color ( AT_MAGIC, ch );
			send_to_char ( "You weave arcane gestures, but the spell does nothing.\r\n", ch );
			return rSPELL_FAILED;
		}
	}
	/*
	 * Remove ALL affects generated by spells, and kill the AFF_X bit for it as well
	 */
	for ( paf = victim->first_affect; paf != NULL; paf = paf_next )
	{
		paf_next = paf->next;
		if ( ( skill = get_skilltype ( paf->type ) ) != NULL )
		{
			if ( skill->type == SKILL_SPELL )
			{
				if ( skill->msg_off )
					ch_printf ( victim, "%s\r\n", skill->msg_off );
				xREMOVE_BIT ( victim->affected_by, paf->modifier );
				affect_remove ( victim, paf );
			}
		}
	}
	/*
	 * Now we get to do the hard part - step thru and look for things to dispel when it's not set by a spell.
	 */
	if ( IS_AFFECTED ( victim, AFF_SANCTUARY ) )
		xREMOVE_BIT ( victim->affected_by, AFF_SANCTUARY );
	if ( IS_AFFECTED ( victim, AFF_CURSE ) )
		xREMOVE_BIT ( victim->affected_by, AFF_CURSE );
	if ( IS_AFFECTED ( victim, AFF_PROTECT ) )
		xREMOVE_BIT ( victim->affected_by, AFF_PROTECT );
	if ( IS_AFFECTED ( victim, AFF_POISON ) )
		xREMOVE_BIT ( victim->affected_by, AFF_POISON );
	if ( IS_AFFECTED ( victim, AFF_INVISIBLE ) )
		xREMOVE_BIT ( victim->affected_by, AFF_INVISIBLE );
	
	
	set_char_color ( AT_MAGIC, ch );
	ch_printf ( ch, "You weave arcane gestures, and %s's spells are negated!\r\n", IS_NPC ( victim ) ? victim->short_descr : victim->name );
	/*
	 * Have to reset victim's racial and eq affects etc
	 */
	if ( !IS_NPC ( victim ) )
		update_aris ( victim );
	if ( IS_NPC ( victim ) )
	{
		if ( !ch->fighting || ( ch->fighting && ch->fighting->who != victim ) )
			multi_hit ( ch, victim, TYPE_UNDEFINED );
	}
	return rNONE;
}

ch_ret spell_remove_curse ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	OBJ_DATA *obj;
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	SKILLTYPE *skill = get_skilltype ( sn );
	if ( IS_SET ( victim->immune, RIS_MAGIC ) )
	{
		immune_casting ( skill, ch, victim, NULL );
		return rSPELL_FAILED;
	}
	if ( is_affected ( victim, gsn_curse ) )
	{
		affect_strip ( victim, gsn_curse );
		set_char_color ( AT_MAGIC, victim );
		send_to_char ( "The weight of your curse is lifted.\r\n", victim );
		if ( ch != victim )
		{
			act ( AT_MAGIC, "You dispel the curses afflicting $N.", ch, NULL, victim, TO_CHAR );
			act ( AT_MAGIC, "$n's dispels the curses afflicting $N.", ch, NULL, victim, TO_NOTVICT );
		}
	}
	else if ( victim->first_carrying )
	{
		for ( obj = victim->first_carrying; obj; obj = obj->next_content )
			if ( !obj->in_obj && ( IS_OBJ_STAT ( obj, ITEM_NOREMOVE ) || IS_OBJ_STAT ( obj, ITEM_NODROP ) ) )
			{
				if ( IS_OBJ_STAT ( obj, ITEM_NOREMOVE ) )
					xREMOVE_BIT ( obj->extra_flags, ITEM_NOREMOVE );
				if ( IS_OBJ_STAT ( obj, ITEM_NODROP ) )
					xREMOVE_BIT ( obj->extra_flags, ITEM_NODROP );
				set_char_color ( AT_MAGIC, victim );
				send_to_char ( "You feel a burden released.\r\n", victim );
				if ( ch != victim )
				{
					act ( AT_MAGIC, "You dispel the curses afflicting $N.", ch, NULL, victim, TO_CHAR );
					act ( AT_MAGIC, "$n's dispels the curses afflicting $N.", ch, NULL, victim, TO_NOTVICT );
				}
				return rNONE;
			}
	}
	return rNONE;
}

ch_ret spell_identify ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	OBJ_DATA *obj;
	AFFECT_DATA *paf;
	SKILLTYPE *sktmp;

	if ( target_name[0] == STRING_NULL )
	{
		send_to_char ( "What should the spell be cast upon?\r\n", ch );
		return rSPELL_FAILED;
	}
	if ( ( obj = get_obj_carry ( ch, target_name ) ) != NULL )
	{
		set_char_color ( AT_IDENTIFY, ch );
		send_to_char ( "&D--------------------------------------------------------------------------------\r\n", ch );
		ch_printf ( ch, "Object: &w'%s&D'\r\n",  obj->short_descr );
		send_to_char ( "&D--------------------------------------------------------------------------------\r\n", ch );
		ch_printf ( ch, "Item Type    : &w%s&D\r\n", item_type_name ( obj ) );

		if ( obj->item_type != ITEM_LIGHT && obj->wear_flags - 1 > 0 )
			ch_printf ( ch, "Wear location:&w %s&D\r\n", flag_string ( obj->wear_flags, w_flags ) );

		ch_printf ( ch, "Weight       :&w %d&D\r\n", obj->weight );
		ch_printf ( ch, "Level        :&w %d&D\r\n", obj->level );
		ch_printf ( ch, "Cost         :&w %d&D\r\n", obj->cost );
		ch_printf ( ch, "Flags        :&w %s&D\r\n", extra_bit_name ( &obj->extra_flags ) );

		switch ( obj->item_type )
		{
			case ITEM_CONTAINER:
				ch_printf ( ch, "&wCapacity     : %d&D items.\r\n", obj->value[0] );
				break;
			case ITEM_PILL:
			case ITEM_SCROLL:
			case ITEM_POTION:
				ch_printf ( ch, "Level %d spells of:", obj->value[0] );
				if ( obj->value[1] >= 0 && ( sktmp = get_skilltype ( obj->value[1] ) ) != NULL )
				{
					send_to_char ( " '", ch );
					send_to_char ( sktmp->name, ch );
					send_to_char ( "'", ch );
				}
				if ( obj->value[2] >= 0 && ( sktmp = get_skilltype ( obj->value[2] ) ) != NULL )
				{
					send_to_char ( " '", ch );
					send_to_char ( sktmp->name, ch );
					send_to_char ( "'", ch );
				}
				if ( obj->value[3] >= 0 && ( sktmp = get_skilltype ( obj->value[3] ) ) != NULL )
				{
					send_to_char ( " '", ch );
					send_to_char ( sktmp->name, ch );
					send_to_char ( "'", ch );
				}
				send_to_char ( ".\r\n", ch );
				break;
			case ITEM_SALVE:
				ch_printf ( ch, "Has %d(%d) applications of level %d", obj->value[1], obj->value[2], obj->value[0] );
				if ( obj->value[4] >= 0 && ( sktmp = get_skilltype ( obj->value[4] ) ) != NULL )
				{
					send_to_char ( " '", ch );
					send_to_char ( sktmp->name, ch );
					send_to_char ( "'", ch );
				}
				if ( obj->value[5] >= 0 && ( sktmp = get_skilltype ( obj->value[5] ) ) != NULL )
				{
					send_to_char ( " '", ch );
					send_to_char ( sktmp->name, ch );
					send_to_char ( "'", ch );
				}
				send_to_char ( ".\r\n", ch );
				break;
			case ITEM_WAND:
			case ITEM_STAFF:
				ch_printf ( ch, "Has %d(%d) charges of level %d", obj->value[1], obj->value[2], obj->value[0] );
				if ( obj->value[3] >= 0 && ( sktmp = get_skilltype ( obj->value[3] ) ) != NULL )
				{
					send_to_char ( " '", ch );
					send_to_char ( sktmp->name, ch );
					send_to_char ( "'", ch );
				}
				send_to_char ( ".\r\n", ch );
				break;
			case ITEM_WEAPON:
				ch_printf ( ch, "Damage       : &w%d &Dto &w%d &D(average &w%d&D)\r\n", obj->value[1], obj->value[2], ( obj->value[1] + obj->value[2] ) / 2 );
				ch_printf ( ch, "Skill needed : &w%s&D\r\n", weapon_skills[obj->value[4]] );
				ch_printf ( ch, "Damage type  : &w%s&D\r\n", attack_table[obj->value[3]] );
				break;
			case ITEM_MISSILE_WEAPON:
				ch_printf ( ch, "Bonus damage added to projectiles is %d to %d (average %d).\r\n", obj->value[1], obj->value[2], ( obj->value[1] + obj->value[2] ) / 2 );
				ch_printf ( ch, "Skill needed:      %s\r\n", weapon_skills[obj->value[4]] );
				ch_printf ( ch, "Projectiles fired: %s\r\n", projectiles[obj->value[5]] );
				break;
			case ITEM_PROJECTILE:
				ch_printf ( ch, "Damage is %d to %d (average %d)%s\r\n",
				            obj->value[1], obj->value[2], ( obj->value[1] + obj->value[2] ) / 2, IS_OBJ_STAT ( obj, ITEM_POISONED ) ? ", and is poisonous." : "." );
				ch_printf ( ch, "Damage type: %s\r\n", attack_table[obj->value[3]] );
				ch_printf ( ch, "Projectile type: %s\r\n", projectiles[obj->value[4]] );
				break;
			case ITEM_ARMOR:
				ch_printf ( ch, "Armor Class  : &w%d&D.\r\n", obj->value[0] );
				break;
		}
		for ( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
			showaffect ( ch, paf );
		for ( paf = obj->first_affect; paf; paf = paf->next )
			showaffect ( ch, paf );
		send_to_char ( "--------------------------------------------------------------------------------\r\n", ch );
		return rNONE;
	}
	else
	{
		ch_printf ( ch, "You can't find %s!\r\n", target_name );
		return rSPELL_FAILED;
	}
	return rNONE;
}

ch_ret spell_blindness ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	SKILLTYPE *skill = get_skilltype ( sn );

	if ( IS_SET ( victim->immune, RIS_MAGIC ) )
	{
		immune_casting ( skill, ch, victim, NULL );
		return rSPELL_FAILED;
	}
	if ( IS_AFFECTED ( victim, AFF_BLIND ) || saves_mental ( victim ) )
	{
		failed_casting ( skill, ch, victim, NULL );
		return rSPELL_FAILED;
	}
	af.type = sn;
	af.location = APPLY_HITROLL;
	af.modifier = -4;
	af.duration = ( 1 +  level ) * DUR_CONV;
	af.bitvector = meb ( AFF_BLIND );
	affect_to_char ( victim, &af );
	set_char_color ( AT_MAGIC, victim );
	send_to_char ( "You are blinded!\r\n", victim );
	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of blindness around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of blindness about $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return rNONE;
}

ch_ret spell_curse ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;
	SKILLTYPE *skill = get_skilltype ( sn );
	if ( IS_SET ( victim->immune, RIS_MAGIC ) )
	{
		immune_casting ( skill, ch, victim, NULL );
		return rSPELL_FAILED;
	}
	if ( IS_AFFECTED ( victim, AFF_CURSE ) || saves_mental ( victim ) )
	{
		failed_casting ( skill, ch, victim, NULL );
		return rSPELL_FAILED;
	}
	af.type = sn;
	af.duration = level * DUR_CONV;
	af.location = APPLY_HITROLL;
	af.modifier = -1;
	af.bitvector = meb ( AFF_CURSE );
	affect_to_char ( victim, &af );
	af.location = APPLY_SAVING_MENTAL;
	af.modifier = 1;
	affect_to_char ( victim, &af );
	set_char_color ( AT_MAGIC, victim );
	send_to_char ( "You feel unclean.\r\n", victim );
	if ( ch != victim )
	{
		act ( AT_MAGIC, "You utter a curse upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n utters a curse upon $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return rNONE;
}


ch_ret spell_poison ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	bool first = TRUE;

	if ( saves_poison_death ( victim ) )
	{
		set_char_color ( AT_MAGIC, ch );
		send_to_char ( "Your magic fails to take hold.\r\n", ch );
		return rSPELL_FAILED;
	}
	if ( IS_AFFECTED ( victim, AFF_POISON ) )
		first = FALSE;
	af.type = sn;
	af.duration = level * DUR_CONV;
	af.location = APPLY_STR;
	af.modifier = -2;
	af.bitvector = meb ( AFF_POISON );
	affect_join ( victim, &af );
	set_char_color ( AT_GREEN, victim );
	send_to_char ( "You feel very sick.\r\n", victim );
	if ( ch != victim )
	{
		act ( AT_GREEN, "$N shivers as your poison spreads through $S body.", ch, NULL, victim, TO_CHAR );
		act ( AT_GREEN, "$N shivers as $n's poison spreads through $S body.", ch, NULL, victim, TO_NOTVICT );
	}
	return rNONE;
}

ch_ret spell_enchant_armor ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	OBJ_DATA *obj = ( OBJ_DATA * ) vo;
	AFFECT_DATA *paf;
	int aenchant;
	int oldaffect, exchance;
	if ( obj->item_type != ITEM_ARMOR )
	{
		act ( AT_MAGIC, "Winding and twisting about $p your magic fails to take hold.", ch, obj, NULL, TO_CHAR );
		act ( AT_MAGIC, "As energy twists and winds about $p, $n's magic fails to take hold.", ch, obj, NULL, TO_NOTVICT );
		return rSPELL_FAILED;
	}
	aenchant = ( number_percent( ) / 5 ) + ( ( get_curr_int ( ch ) / 6 ) + ( get_curr_lck ( ch ) / 10 ) ); /* Generate BASE enchant chance */
	separate_obj ( obj ); /* REMOVE the object to save BUG/CRASH (In Case) */
	exchance = 0;  /* Use ANY modifers to HR and DR to increase change of EXPLODE or FADE */
	for ( paf = obj->first_affect; paf; paf = paf->next )
	{
		if ( paf->location == APPLY_AC )
		{
			exchance += paf->modifier;
		}
	}
	if ( number_percent( ) > 30 )
	{
		aenchant += exchance;   /* Increase EXPLODE chance (70%)  LEVEL DIFF between OBJ and CH increases this */
		if ( obj->level > ch->level )
			aenchant += ( obj->level - ch->level + 1 );
	}
	else if ( number_percent( ) > 50 )
	{
		aenchant -= exchance;   /* Increase FADE chance (50%)  LEVEL DIFF between OBJ and CH increases this */
		if ( obj->level > ch->level )
			aenchant -= ( obj->level - ch->level + 1 );
	}
	if ( aenchant >= 40 )
	{
		/*
		 * EXPLODE
		 */
		act ( AT_FIRE, "In a fiery display $p violently explodes.", ch, obj, NULL, TO_CHAR );
		act ( AT_FIRE, "In a shower of shards $p violently explodes.", ch, obj, NULL, TO_NOTVICT );
		extract_obj ( obj );
	}
	else if ( aenchant >= 10 )
	{
		oldaffect = 5; /* NORMAL */
		if ( aenchant <= 20 )
		{
			oldaffect++;
		}
		if ( !obj->first_affect )
		{
			CREATE ( paf, AFFECT_DATA, 1 );
			paf->type = -1;
			paf->duration = -1;
			paf->location = APPLY_AC;
			paf->modifier = oldaffect;
			xCLEAR_BITS ( paf->bitvector );
			LINK ( paf, obj->first_affect, obj->last_affect, next, prev );
		}
		else
		{
			for ( paf = obj->first_affect; paf; paf = paf->next )
			{
				if ( paf->location == APPLY_AC )
				{
					oldaffect = paf->modifier;
					UNLINK ( paf, obj->first_affect, obj->last_affect, next, prev );
				}
			}
			if ( aenchant >= 23 )
			{
				oldaffect += 3;
			}
			else
			{
				oldaffect += 2;
			}
			if ( oldaffect >= 15 )
			{
				act ( AT_MAGIC, "This item can take no more magic.", ch, obj, NULL, TO_CHAR );
				oldaffect = 15;
			}
			CREATE ( paf, AFFECT_DATA, 1 );
			paf->type = -1;
			paf->duration = -1;
			paf->location = APPLY_AC;
			paf->modifier = oldaffect;
			xCLEAR_BITS ( paf->bitvector );
			LINK ( paf, obj->first_affect, obj->last_affect, next, prev );
		}
		if ( aenchant >= 23 )
		{
			xSET_BIT ( obj->extra_flags, ITEM_GLOW );
			act ( AT_BYE, "In a swirl of color $p glows with fantastic brightness.", ch, obj, NULL, TO_CHAR );
			act ( AT_BYE, "In a shower of color $p suddenly glows with fantastic brilliance.", ch, obj, NULL, TO_NOTVICT );
		}
		else
		{
			act ( AT_MAGIC, "As the magic takes hold $p glows a lovely blue.", ch, obj, NULL, TO_CHAR );
			act ( AT_MAGIC, "$n's magic take hold and makes $p glow a lovely blue.", ch, obj, NULL, TO_NOTVICT );
		}
	}
	else if ( aenchant >= 4 )
	{
		/*
		 * NOTHING
		 */
		act ( AT_PLAIN, "Nothing Happens.", ch, obj, NULL, TO_CHAR );
		act ( AT_PLAIN, "$n's magic fails to take hold on $p.", ch, obj, NULL, TO_NOTVICT );
	}
	else if ( aenchant < 4 ) /* FADE any ENCHANTS and FLAGS */
	{
		for ( paf = obj->first_affect; paf; paf = paf->next )
		{
			if ( paf->location == APPLY_AC )
			{
				UNLINK ( paf, obj->first_affect, obj->last_affect, next, prev );
			}
		}  /* now remove FLAGS */
		if ( IS_OBJ_STAT ( obj, ITEM_GLOW ) )
			xREMOVE_BIT ( obj->extra_flags, ITEM_GLOW );
		if ( IS_OBJ_STAT ( obj, ITEM_MAGIC ) )
			xREMOVE_BIT ( obj->extra_flags, ITEM_MAGIC );
		act ( AT_MAGIC, "With a dull light $p fades slightly.", ch, obj, NULL, TO_CHAR );
		act ( AT_MAGIC, "Suddenly $p glows brightly and then fades.", ch, obj, NULL, TO_NOTVICT );
		learn_from_failure ( ch, gsn_enchant_armor );
		return rNONE;

	}
	learn_from_success ( ch, gsn_enchant_armor );
	return rNONE;
}

ch_ret spell_enchant_weapon ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	OBJ_DATA *obj = ( OBJ_DATA * ) vo;
	AFFECT_DATA *paf;
	int aenchant;
	int oldaffect, exchance;
	if ( obj->item_type != ITEM_WEAPON )
	{
		act ( AT_MAGIC, "Winding and twisting about $p your magic fails to take hold.", ch, obj, NULL, TO_CHAR );
		act ( AT_MAGIC, "As energy twists and winds about $p, $n's magic fails to take hold.", ch, obj, NULL, TO_NOTVICT );
		return rSPELL_FAILED;
	}
	aenchant = ( number_percent( ) / 5 ) + ( ( get_curr_int ( ch ) / 6 ) + ( get_curr_lck ( ch ) / 10 ) ); /* Generate BASE enchant chance */
	separate_obj ( obj ); /* REMOVE the object to save BUG/CRASH (In Case) */
	exchance = 0;  /* Use ANY modifers to HR and DR to increase change of EXPLODE or FADE */
	for ( paf = obj->first_affect; paf; paf = paf->next )
	{
		if ( paf->location == APPLY_HITROLL || paf->location == APPLY_DAMROLL )
		{
			exchance += paf->modifier;
		}
	}
	if ( number_percent( ) > 30 )
	{
		aenchant += exchance;   /* Increase EXPLODE chance (70%)  LEVEL DIFF between OBJ and CH increases this */
		if ( obj->level > ch->level )
			aenchant += ( obj->level - ch->level + 1 );
	}
	else if ( number_percent( ) > 50 )
	{
		aenchant -= exchance;   /* Increase FADE chance (50%)  LEVEL DIFF between OBJ and CH increases this */
		if ( obj->level > ch->level )
			aenchant -= ( obj->level - ch->level + 1 );
	}
	if ( aenchant >= 40 )
	{
		/*
		 * EXPLODE
		 */
		act ( AT_FIRE, "In a fiery display $p violently explodes.", ch, obj, NULL, TO_CHAR );
		act ( AT_FIRE, "In a shower of shards $p violently explodes.", ch, obj, NULL, TO_NOTVICT );
		extract_obj ( obj );
	}
	else if ( aenchant >= 10 )
	{
		oldaffect = 5; /* NORMAL */
		if ( aenchant <= 20 )
		{
			oldaffect++;
		}
		if ( !obj->first_affect )
		{
			CREATE ( paf, AFFECT_DATA, 1 );
			paf->type = -1;
			paf->duration = -1;
			paf->location = APPLY_HITROLL;
			paf->modifier = oldaffect;
			xCLEAR_BITS ( paf->bitvector );
			LINK ( paf, obj->first_affect, obj->last_affect, next, prev );
			CREATE ( paf, AFFECT_DATA, 1 );
			paf->type = -1;
			paf->duration = -1;
			paf->location = APPLY_DAMROLL;
			paf->modifier = oldaffect;
			xCLEAR_BITS ( paf->bitvector );
			LINK ( paf, obj->first_affect, obj->last_affect, next, prev );
		}
		else
		{
			for ( paf = obj->first_affect; paf; paf = paf->next )
			{
				if ( paf->location == APPLY_HITROLL || paf->location == APPLY_DAMROLL )
				{
					oldaffect = paf->modifier;
					UNLINK ( paf, obj->first_affect, obj->last_affect, next, prev );
				}
			}
			if ( aenchant >= 23 )
			{
				oldaffect += 3;
			}
			else
			{
				oldaffect += 2;
			}
			if ( oldaffect >= 15 )
			{
				act ( AT_MAGIC, "This item can take no more magic.", ch, obj, NULL, TO_CHAR );
				oldaffect = 10;
			}
			CREATE ( paf, AFFECT_DATA, 1 );
			paf->type = -1;
			paf->duration = -1;
			paf->location = APPLY_HITROLL;
			paf->modifier = oldaffect;
			xCLEAR_BITS ( paf->bitvector );
			LINK ( paf, obj->first_affect, obj->last_affect, next, prev );
			CREATE ( paf, AFFECT_DATA, 1 );
			paf->type = -1;
			paf->duration = -1;
			paf->location = APPLY_DAMROLL;
			paf->modifier = oldaffect;
			xCLEAR_BITS ( paf->bitvector );
			LINK ( paf, obj->first_affect, obj->last_affect, next, prev );
		}
		if ( aenchant >= 23 )
		{
			xSET_BIT ( obj->extra_flags, ITEM_GLOW );
			act ( AT_BYE, "In a swirl of color $p glows with fantastic brightness.", ch, obj, NULL, TO_CHAR );
			act ( AT_BYE, "In a shower of color $p suddenly glows with fantastic brilliance.", ch, obj, NULL, TO_NOTVICT );
		}
		else
		{
			act ( AT_MAGIC, "As the magic takes hold $p glows a lovely blue.", ch, obj, NULL, TO_CHAR );
			act ( AT_MAGIC, "$n's magic take hold and makes $p glow a lovely blue.", ch, obj, NULL, TO_NOTVICT );
		}
	}
	else if ( aenchant >= 4 )
	{
		/*
		 * NOTHING
		 */
		act ( AT_PLAIN, "Nothing Happens.", ch, obj, NULL, TO_CHAR );
		act ( AT_PLAIN, "$n's magic fails to take hold on $p.", ch, obj, NULL, TO_NOTVICT );
	}
	else if ( aenchant < 4 ) /* FADE any ENCHANTS and FLAGS */
	{
		for ( paf = obj->first_affect; paf; paf = paf->next )
		{
			if ( paf->location == APPLY_HITROLL || paf->location == APPLY_DAMROLL )
			{
				UNLINK ( paf, obj->first_affect, obj->last_affect, next, prev );
			}
		}  /* now remove FLAGS */
		if ( IS_OBJ_STAT ( obj, ITEM_GLOW ) )
			xREMOVE_BIT ( obj->extra_flags, ITEM_GLOW );
		if ( IS_OBJ_STAT ( obj, ITEM_MAGIC ) )
			xREMOVE_BIT ( obj->extra_flags, ITEM_MAGIC );
		act ( AT_MAGIC, "With a dull light $p fades slightly.", ch, obj, NULL, TO_CHAR );
		act ( AT_MAGIC, "Suddenly $p glows brightly and then fades.", ch, obj, NULL, TO_NOTVICT );
		learn_from_failure ( ch, gsn_enchant_weapon );
		return rNONE;
	}
	learn_from_success ( ch, gsn_enchant_armor );
	return rNONE;
}

ch_ret spell_dark_hand ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( ch->level > 5 && ch->level < 11 )
		dam *= 1.25;
	else if ( ch->level > 9 && ch->level < 16 )
		dam *= 1.5;
	else if ( ch->level > 14 && ch->level < 21 )
		dam *= 2;
	else if ( ch->level > 19 && ch->level < 26 )
		dam *= 2.25;
	else
		dam *= 2.5;

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to deflect some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n concentrates, sending dark ki into $N body.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "Logs and debris hits $N", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n concentrates, sending dark ki into $N body.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_root ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( ch->level > 5 && ch->level < 11 )
		dam *= 1.25;
	else if ( ch->level > 9 && ch->level < 16 )
		dam *= 1.5;
	else if ( ch->level > 14 && ch->level < 21 )
		dam *= 2;
	else if ( ch->level > 19 && ch->level < 26 )
		dam *= 2.25;
	else
		dam *= 2.5;

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to deflect some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "Green essence flies into the ground from the hands of $n roots entangle $N throat.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "Roots from the ground entangle $N throat.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "Green essence flies into the ground from the hands of $n roots entangle $N throat.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}
ch_ret spell_palm_flare ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( ch->level > 5 && ch->level < 11 )
		dam *= 1.25;
	else if ( ch->level > 9 && ch->level < 16 )
		dam *= 1.5;
	else if ( ch->level > 14 && ch->level < 21 )
		dam *= 2;
	else if ( ch->level > 19 && ch->level < 26 )
		dam *= 2.25;
	else
		dam *= 2.5;

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to deflect some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n sends a ki blast directly at $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A blast of ki hits $N in the chest", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n sends a ki blast directly at $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_armor ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	af.type = sn;
	af.location = APPLY_AC;
	af.modifier = level*-1;
	af.duration = 4 * DUR_CONV;
	af.bitvector = meb ( -1 );
	if ( is_affected ( victim, sn ) )
		affect_join( victim, &af );
	else
		affect_to_char ( victim, &af );
	
	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of armor around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of armor around you..", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a spell of armor about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "You weave a spell of armor around yourself.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of armor about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_heal ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;

	if ( victim->hit == victim->max_hit )
	{
		send_to_char ( "You are already at maximum health.\n\r", victim );
		return rSPELL_FAILED;
	}
	victim->hit += UMIN ( victim->level * 3, victim->max_hit );
	if ( victim->hit >= victim->max_hit )
		victim->hit = victim->max_hit;
	update_pos ( victim );

	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of healing around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A warm feeling fills your body and you feel healed", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a spell of healing about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "A warm feeling fills your body and you feel healed", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of healing about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_refresh ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;

	if ( victim->move == victim->max_move )
	{
		send_to_char ( "You are already at maximum movement.\n\r", victim );
		return rSPELL_FAILED;
	}
	victim->move += UMIN ( victim->level * 3, victim->max_move );
	if ( victim->move >= victim->max_move )
		victim->move = victim->max_move;
	update_pos ( victim );

	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of refresh around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A warm feeling fills your body and you feel refreshed", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a spell of refresh about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "A warm feeling fills your body and you feel refreshed", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of refresh about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_sanctuary ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	af.type = sn;
	af.location = APPLY_NONE;
	af.modifier = 0;
	af.duration = 4 * DUR_CONV;
	af.bitvector = meb ( AFF_SANCTUARY );
	if ( is_affected ( victim, sn ) )
		affect_join( victim, &af );
	else
		affect_to_char ( victim, &af );

	if ( ch != victim )
	{
		act ( AT_MAGIC, "A luminous aura spreads slowly over $N's body.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a luminous aura about your body.", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a luminous aura about $N's body.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "A luminous aura spreads slowly over your body!.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a luminous aura about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_shield ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	af.type = sn;
	af.location = APPLY_AC;
	af.modifier = -20;
	af.duration = ( 1 +  level ) * DUR_CONV;
	if ( is_affected ( victim, sn ) )
		affect_join( victim, &af );
	else
		affect_to_char ( victim, &af );

	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of shielding around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a shielding spell about your body.", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a shielding spell about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "You feel more resistant to damage!", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a shielding spel about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_giant_strength ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	af.type = sn;
	af.duration = ( 1 +  level ) * DUR_CONV;
	af.location = APPLY_STR;
	af.modifier = 4;
	if ( is_affected ( victim, sn ) )
		affect_join( victim, &af );
	else
		affect_to_char ( victim, &af );

	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of giant strength around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "Your muscles surge with heightened power!", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a spell of giant strength about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "Your muscles surge with heightened power!", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of giant strength about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_haste ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	af.type = sn;
	af.duration = ( 1 +  level ) * DUR_CONV;
	af.location = APPLY_DEX;
	af.modifier = 4;
	if ( is_affected ( victim, sn ) )
		affect_join( victim, &af );
	else
		affect_to_char ( victim, &af );

	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of giant strength around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "Your muscles surge with heightened power!", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a spell of giant strength about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "Your muscles surge with heightened power!", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of giant strength about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_invisible ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	AFFECT_DATA af;

	af.type = sn;
	af.duration = 4 * DUR_CONV;
	af.location = APPLY_NONE;
	af.modifier = 0;
	af.bitvector = meb ( AFF_INVISIBLE );
	if ( is_affected ( victim, sn ) )
		affect_join( victim, &af );
	else
		affect_to_char ( victim, &af );

	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of invisibility around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "You slowly fade out of existance!", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a spell of invisibilty about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "You fade out of existance!", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of invisibility about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

ch_ret spell_detect_invis (int sn, int level, CHAR_DATA * ch, void *vo)
{
	CHAR_DATA *victim = (CHAR_DATA *) vo;
	AFFECT_DATA af;

	af.type = sn;
	af.duration = 4 * DUR_CONV;
	af.modifier = 0;
	af.location = APPLY_NONE;
	af.bitvector = meb ( AFF_DETECT_INVIS );
	if ( is_affected ( victim, sn ) )
		affect_join( victim, &af );
	else
		affect_to_char ( victim, &af );


	if ( ch != victim )
	{
		act ( AT_MAGIC, "You weave a spell of detect invisibility around $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "Your eyes tingle with heightend sensitivity!", ch, NULL, victim, TO_VICT );
		act ( AT_MAGIC, "$n weaves a spell of detect invisibility about $N.", ch, NULL, victim, TO_NOTVICT );
		
	}
	else
	{
		act ( AT_MAGIC, "Your eyes tingle with heightend sensitivity!", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n weaves a spell of detect invisibility about himself.", ch, NULL, victim, TO_ROOM );

	}
	return rNONE;
}

/* area attack spells */

ch_ret spell_earthquake ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *vch;
	CHAR_DATA *vch_next;
	bool ch_died;
	ch_ret retcode;
	SKILLTYPE *skill = get_skilltype ( sn );

	ch_died = FALSE;
	retcode = rNONE;

	if ( xIS_SET ( ch->in_room->room_flags, ROOM_SAFE ) )
	{
		failed_casting ( skill, ch, NULL, NULL );
		return rSPELL_FAILED;
	}

	act ( AT_MAGIC, "The earth trembles beneath your feet!", ch, NULL, NULL, TO_CHAR );
	act ( AT_MAGIC, "$n makes the earth tremble and shiver.", ch, NULL, NULL, TO_ROOM );

	for ( vch = first_char; vch; vch = vch_next )
	{
		vch_next = vch->next;
		if ( !vch->in_room )
			continue;
		if ( vch->in_room == ch->in_room && ( vch->x == ch->x && vch->y == ch->y ) )
		{
			if ( !IS_NPC ( vch ) && xIS_SET ( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
				continue;

			if ( vch != ch && ( IS_NPC ( ch ) ? !IS_NPC ( vch ) : IS_NPC ( vch ) )
			        && !IS_AFFECTED ( vch, AFF_FLYING ) && !IS_AFFECTED ( vch, AFF_FLOATING ) )
				retcode = damage ( ch, vch, level + dice ( 2, 8 ), sn );
			if ( retcode == rCHAR_DIED || char_died ( ch ) )
			{
				ch_died = TRUE;
				continue;
			}
			if ( char_died ( vch ) )
				continue;
		}

		if ( !ch_died && vch->in_room->area == ch->in_room->area )
		{
			if ( number_bits ( 3 ) == 0 )
				send_to_char_color ( "&BThe earth trembles and shivers.\r\n", vch );
		}
	}

	if ( ch_died )
		return rCHAR_DIED;
	else
		return rNONE;
}

ch_ret spell_volcano ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *vch;
	CHAR_DATA *vch_next;
	bool ch_died;
	ch_ret retcode;
	SKILLTYPE *skill = get_skilltype ( sn );

	ch_died = FALSE;
	retcode = rNONE;

	if ( xIS_SET ( ch->in_room->room_flags, ROOM_SAFE ) )
	{
		failed_casting ( skill, ch, NULL, NULL );
		return rSPELL_FAILED;
	}

	act ( AT_MAGIC, "Red hot lava bursts forth from the ground beneath your feet!", ch, NULL, NULL, TO_CHAR );
	act ( AT_MAGIC, "$n causes red hot lava bursts forth from the ground beneath your feet!", ch, NULL, NULL, TO_ROOM );

	for ( vch = first_char; vch; vch = vch_next )
	{
		vch_next = vch->next;
		if ( !vch->in_room )
			continue;
		if ( vch->in_room == ch->in_room && ( vch->x == ch->x && vch->y == ch->y ) )
		{
			if ( !IS_NPC ( vch ) && xIS_SET ( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
				continue;

			if ( vch != ch && ( IS_NPC ( ch ) ? !IS_NPC ( vch ) : IS_NPC ( vch ) )
			        && !IS_AFFECTED ( vch, AFF_FLYING ) && !IS_AFFECTED ( vch, AFF_FLOATING ) )
				retcode = damage ( ch, vch, level + dice ( 2, 8 ), sn );
			if ( retcode == rCHAR_DIED || char_died ( ch ) )
			{
				ch_died = TRUE;
				continue;
			}
			if ( char_died ( vch ) )
				continue;
		}

		if ( !ch_died && vch->in_room->area == ch->in_room->area )
		{
			if ( number_bits ( 3 ) == 0 )
				send_to_char_color ( "&BThe earth trembles and shivers.\r\n", vch );
		}
	}

	if ( ch_died )
		return rCHAR_DIED;
	else
		return rNONE;
}

ch_ret spell_flood ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *vch;
	CHAR_DATA *vch_next;
	bool ch_died;
	ch_ret retcode;
	SKILLTYPE *skill = get_skilltype ( sn );

	ch_died = FALSE;
	retcode = rNONE;

	if ( xIS_SET ( ch->in_room->room_flags, ROOM_SAFE ) )
	{
		failed_casting ( skill, ch, NULL, NULL );
		return rSPELL_FAILED;
	}

	act ( AT_MAGIC, "Cool water bursts forth from the ground beneath your feet!", ch, NULL, NULL, TO_CHAR );
	act ( AT_MAGIC, "$n causes cool water bursts forth from the ground beneath your feet!", ch, NULL, NULL, TO_ROOM );

	for ( vch = first_char; vch; vch = vch_next )
	{
		vch_next = vch->next;
		if ( !vch->in_room )
			continue;
		if ( vch->in_room == ch->in_room && ( vch->x == ch->x && vch->y == ch->y ) )
		{
			if ( !IS_NPC ( vch ) && xIS_SET ( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
				continue;

			if ( vch != ch && ( IS_NPC ( ch ) ? !IS_NPC ( vch ) : IS_NPC ( vch ) )
			        && !IS_AFFECTED ( vch, AFF_FLYING ) && !IS_AFFECTED ( vch, AFF_FLOATING ) )
				retcode = damage ( ch, vch, level + dice ( 2, 8 ), sn );
			if ( retcode == rCHAR_DIED || char_died ( ch ) )
			{
				ch_died = TRUE;
				continue;
			}
			if ( char_died ( vch ) )
				continue;
		}

		if ( !ch_died && vch->in_room->area == ch->in_room->area )
		{
			if ( number_bits ( 3 ) == 0 )
				send_to_char_color ( "&BThe earth trembles and shivers.\r\n", vch );
		}
	}

	if ( ch_died )
		return rCHAR_DIED;
	else
		return rNONE;
}

ch_ret spell_tornado ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *vch;
	CHAR_DATA *vch_next;
	bool ch_died;
	ch_ret retcode;
	SKILLTYPE *skill = get_skilltype ( sn );

	ch_died = FALSE;
	retcode = rNONE;

	if ( xIS_SET ( ch->in_room->room_flags, ROOM_SAFE ) )
	{
		failed_casting ( skill, ch, NULL, NULL );
		return rSPELL_FAILED;
	}

	act ( AT_MAGIC, "Strong winds blow up all around, smashing you with debris!", ch, NULL, NULL, TO_CHAR );
	act ( AT_MAGIC, "$n causes strong winds blow up all around, smashing you with debris!", ch, NULL, NULL, TO_ROOM );

	for ( vch = first_char; vch; vch = vch_next )
	{
		vch_next = vch->next;
		if ( !vch->in_room )
			continue;
		if ( vch->in_room == ch->in_room && ( vch->x == ch->x && vch->y == ch->y ) )
		{
			if ( !IS_NPC ( vch ) && xIS_SET ( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
				continue;

			if ( vch != ch && ( IS_NPC ( ch ) ? !IS_NPC ( vch ) : IS_NPC ( vch ) ) )
				retcode = damage ( ch, vch, level + dice ( 2, 8 ), sn );
			if ( retcode == rCHAR_DIED || char_died ( ch ) )
			{
				ch_died = TRUE;
				continue;
			}
			if ( char_died ( vch ) )
				continue;
		}

		if ( !ch_died && vch->in_room->area == ch->in_room->area )
		{
			if ( number_bits ( 3 ) == 0 )
				send_to_char_color ( "&BThe earth trembles and shivers.\r\n", vch );
		}
	}

	if ( ch_died )
		return rCHAR_DIED;
	else
		return rNONE;
}

/* foundation attack spells*/

ch_ret spell_fireball ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A ball of blue flames flys forth from $n's outstretched hand enveloping $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A ball of blue flames explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A ball of blue flames flys forth from $n's outstretched hand enveloping $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_flamestrike ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A jet of red and yellow flames flys forth from $n's outstretched hand enveloping $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A jet of red and yellow flames explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A jet of red and yellow flames flys forth from $n's outstretched hand enveloping $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_ice_storm ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n causes sheets of hail to fall upon $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A sheet of ice explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n bombards $N with hail and ice.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_water_wall ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n fires a compressed wall of water at $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A wall of compressed water explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A wall of compressed water flys forth from $n's outstretched hand, smashing $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}


ch_ret spell_gas_blast ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n fires a compressed wall of gas at $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A wall of compressed gas explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A wall of compressed gas flys forth from $n's outstretched hand, smashing $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_air_spike ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n fires a spike of air at $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A spike of air explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A spike of air flys forth from $n's outstretched hand, smashing $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_earth_blast ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n fires a blash of earth at $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A blast of earth explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A blast of earth flys forth from $n's outstretched hand, smashing $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}

ch_ret spell_dirt_spike ( int sn, int level, CHAR_DATA * ch, void *vo )
{
	CHAR_DATA *victim = ( CHAR_DATA * ) vo;
	int dam;
	dam = dice ( level, 6 );

	if ( saves_mental ( victim ) )
	{
		dam /= 2;
		act ( AT_MAGIC, "$N is able to defelct some of your magic.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "$n fires a spike of dirt at $N.", ch, NULL, victim, TO_NOTVICT );
	}
	else
	{
		act ( AT_MAGIC, "A spike of dirth explodes upon $N.", ch, NULL, victim, TO_CHAR );
		act ( AT_MAGIC, "A spike of dirt flys forth from $n's outstretched hand, smashing $N.", ch, NULL, victim, TO_NOTVICT );
	}
	return damage ( ch, victim, dam, sn );
}
